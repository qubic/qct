# QVE-2025-0010: QSWAP Floor Division Pool Drain

**Date Reported:** 2025-12-11
**Status:** Resolved
**Severity:** Critical

## Description
QSWAP exact output swap functions use nested floor divisions to calculate required input amount. When pools are imbalanced, this calculation can round down to zero, allowing users to extract tokens without payment.

## Impact
Complete drainage of liquidity pools. Liquidity providers lose all funds.

## Affected Components
- `src/contracts/Qswap.h`
  - `getAmountInTakeFeeFromInToken()`
  - `getAmountInTakeFeeFromOutToken()`

## Steps to Reproduce
1. Pool state: 5 assets : 49,000,000 QU (imbalanced)
2. Attacker calls `SwapAssetForExactQu` requesting 1,100,000 QU out
3. Required input calculation:
   - `assetIn = (5 × 1,100,000) / (49,000,000 × 0.997 - 1,100,000)`
   - `assetIn = 5,500,000 / 47,753,000 ≈ 0.115`
4. Floor division: `floor(0.115) = 0`
5. Attacker pays 0 assets, receives 1,100,000 QU for free
6. Repeat until pool is drained

## Mitigation / Fix
Changed nested floor divisions to single division with floor + 1, ensuring users always pay at least 1 unit. Matches Uniswap V2 approach.

```cpp
// Before (vulnerable) - nested divisions cause precision loss and can round to 0
tmpRes = div(
    div(
        uint128(reserveIn) * uint128(amountOut),
        uint128(reserveOut - amountOut)
    ) * uint128(QSWAP_SWAP_FEE_BASE),
    uint128(QSWAP_SWAP_FEE_BASE - fee)
);

// After (fixed) - single division + 1 ensures user always pays enough
numerator = uint128(reserveIn) * uint128(amountOut) * uint128(QSWAP_SWAP_FEE_BASE);
denominator = uint128(reserveOut - amountOut) * uint128(QSWAP_SWAP_FEE_BASE - fee);
tmpRes = div(numerator, denominator) + uint128(1);
```

## References
- https://github.com/qubic/core/blob/main/src/contracts/Qswap.h
